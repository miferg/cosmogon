#! /usr/bin/python3
"""
Command line simulation application.

github.com/miferg
"""

import curses
import sys
import random
import data.data as data
from data.network import Network
from data.classes import *
from data.functions import *

################################################################################
# Main function

def cosmogon(stdscr):

    stdscr.nodelay(True)
    k = 0
    n = Network()

    # Clear and refresh the screen for a blank canvas
    stdscr.clear()
    stdscr.refresh()
    stdscr.idcok(False)
    stdscr.idlok(False)

    # Start colors in curses
    col_dict = set_colors()

    # Load objects
    names = data.names
    random.shuffle(names)
    char_dict = data.char_dict
    type_dict = data.type_dict

    # Create a new world
    world = World(names.pop(), 30, 50)
    world.mat = data.testmat.copy()  # Use the provisional matrix 
    world.gen_map(char_dict)
    world.gen_col(col_dict)
    world.pad = gen_world_pad(world)
    pheight, pwidth = world.pad.getmaxyx()

    # Initialize factions
    # local faction
    p, calorigin = n.getP()
    world.factions[p["name"]] = Faction(p["name"])
    timer = 0

    # remote factions
    players = n.send(p)
    for player in players:
        if player != p:
            world.factions[player["name"]] = Faction(player["name"])

    # Start the calendar
    calendar = Calendar()
    calendar.origin = float(calorigin)

    # Define the starting position
    if p == players[0]:
        wpshow = [0,0]
        cursor_x = 0
        cursor_y = 0
    else:
        wpshow = [pheight-12,pwidth-12]
        cursor_x = pwidth-2
        cursor_y = pheight-2

    # Start timer for growth and production
    grow_month = 1
    grow_year = 0

    # No settlements are currently selected
    selected = 0

################################################################################
# Main loop where k is the last character pressed
    while True:

        height, width = stdscr.getmaxyx()

################################################################################
# Network operations

        # Send current faction and recieve all factions
        players = n.send(p)

        for player in players:
            if player['name'] != p['name']:

                if "b" in list(player.keys()): # Build the first settlement
                    world.create_pop(world,player["b"][0],player["b"][1],player["b"][2],player["name"])
                    if (player["b"][0],player["b"][1]) in world.factions[p["name"]].explored:
                        local_refresh_pad(player["b"][0],player["b"][1],char_dict,col_dict,world)
                    del player["b"]

                elif "bt" in list(player.keys()): # Build a town
                    world.pops[tuple(player["bt"])].build_town(world)
                    if tuple(player["bt"]) in world.factions[p["name"]].explored:
                        local_refresh_pad(player["bt"][0],player["bt"][1],char_dict,col_dict,world)
                    del player["bt"]

                elif "bc" in list(player.keys()): # Build a city
                    world.pops[tuple(player["bc"])].build_city(world)
                    if tuple(player["bc"]) in world.factions[p["name"]].explored:
                        local_refresh_pad(player["bc"][0],player["bc"][1],char_dict,col_dict,world)
                    del player["bc"]

                elif "e" in list(player.keys()): # Establish a colony
                    world.pops[tuple(player["e"][0])].colonize(player["e"][1],player["e"][2],world,player["e"][3])
                    if (player["e"][1],player["e"][2]) in world.factions[p["name"]].explored:
                        local_refresh_pad(player["e"][1],player["e"][2],char_dict,col_dict,world)
                    del player["e"]

                elif "o" in list(player.keys()): # Build a fort
                    world.pops[tuple(player["o"][0])].build_fort(player["o"][1],player["o"][2],world)
                    if (player["o"][1],player["o"][2]) in world.factions[p["name"]].explored:
                        local_refresh_pad(player["o"][1],player["o"][2],char_dict,col_dict,world)
                    del player["o"]

                elif "uo" in list(player.keys()): # Upgrade a fort
                    world.pops[tuple(player["uo"][0])].upgrade_fort(player["uo"][1],player["uo"][2],world)
                    if (player["uo"][1],player["uo"][2]) in world.factions[p["name"]].explored:
                        local_refresh_pad(player["uo"][1],player["uo"][2],char_dict,col_dict,world)
                    del player["uo"]

                elif "f" in list(player.keys()): # Build a farm
                    world.pops[tuple(player["f"][0])].build_farm(player["f"][1],player["f"][2],world)
                    if (player["f"][1],player["f"][2]) in world.factions[p["name"]].explored:
                        local_refresh_pad(player["f"][1],player["f"][2],char_dict,col_dict,world)
                    del player["f"]

                elif "c" in list(player.keys()): # Claim wilderness
                    world.pops[tuple(player["c"][0])].claim(player["c"][1],player["c"][2], world)
                    del player["c"]

                elif "x" in list(player.keys()): # Explore
                    world.pops[tuple(player["x"][0])].explore(player["x"][1],player["x"][2], world)
                    del player["x"]

            elif timer > 0:
                timer += -1

            else:
                if "b" in list(player.keys()): # remove instruction Build the first settlement
                    del p["b"]
                elif "bt" in list(player.keys()): # remove instruction Build a town
                    del p["bt"]
                elif "bc" in list(player.keys()): # remove instruction Build a city
                    del p["bc"]
                elif "e" in list(player.keys()): # remove instruction Establish a colony
                    del p["e"]
                elif "o" in list(player.keys()): # remove instruction Build a fort
                    del p["o"]
                elif "uo" in list(player.keys()): # remove instruction Upgrade a fort
                    del p["uo"]
                elif "f" in list(player.keys()): # remove instruction Build a farm
                    del p["f"]
                elif "c" in list(player.keys()): # remove instruction Claim wilderness
                    del p["c"]
                elif "x" in list(player.keys()): # remove instruction Explore
                    del p["x"]

################################################################################
# Input operations

        # Build the first settlement (b)
        if k == 98:
            if world.factions[p["name"]].startpop != 0:
                if (cursor_x,cursor_y) not in world.pops.keys():
                    nwpopname = names.pop()
                    world.create_pop(world, cursor_x,cursor_y, nwpopname, p["name"])
                    world.pad = drop_fog(world)
                    local_refresh_pad(cursor_x, cursor_y, char_dict, col_dict, world)
                    surroundlist = surrounding(cursor_x, cursor_y)
                    for pair in surroundlist:
                        local_refresh_pad(pair[0], pair[1], char_dict, col_dict, world)
                    p["b"] = (cursor_x, cursor_y, nwpopname)
                    timer = 5

        # Select and deselect a settlement (s)
        if k == 115:
            # Select a settlement
            if selected == 0 and (cursor_x, cursor_y) in world.factions[p["name"]].pops:
                selected_pos = (cursor_x, cursor_y)
                world.pad.addstr(cursor_y, cursor_x, str(world.map[(cursor_x,cursor_y)]), curses.color_pair(6))
                selected = 1
            # Select last selected settlement
            elif 'selected_pos' in locals() and selected == 0:
                if (cursor_x, cursor_y) not in world.factions[p["name"]].pops:
                    world.pad.addstr(selected_pos[1],selected_pos[0],str(world.map[selected_pos]), curses.color_pair(6))
                    selected = 1
            # Deselect settlement
            elif selected == 1:
                world.pad.addstr(selected_pos[1],selected_pos[0],str(world.map[selected_pos]), curses.color_pair(5))
                selected = 0

        # Explore tile (s, x)
        if k == 120 and selected == 1:
            selected = 0
            world.pad.addstr(selected_pos[1],selected_pos[0],str(world.map[selected_pos]), curses.color_pair(5))
            diffx = abs(cursor_x-selected_pos[0])
            diffy = abs(cursor_y-selected_pos[1])
            surroundlist = surrounding(cursor_x, cursor_y)
            if world.factions[world.pops[selected_pos].owner].wealth >= 10*(diffx+diffy):
                if world.pops[selected_pos].size >= 10*(diffx+diffy):
                    if bool(set(world.factions[p["name"]].explored) & set(surroundlist)):
                        flag = world.pops[selected_pos].explore(cursor_x, cursor_y, world)
                        local_refresh_pad(cursor_x, cursor_y, char_dict, col_dict, world)
                        if flag == 1:
                            p["x"] = (selected_pos, cursor_x, cursor_y)
                            timer = 5
                            flag = 0

        # Applicable functions to charted world
        if (cursor_x,cursor_y) in world.factions[p["name"]].explored:

            # Claim wilderness (s, c)
            if k == 99 and selected == 1:
                selected = 0
                world.pad.addstr(selected_pos[1],selected_pos[0],str(world.map[selected_pos]), curses.color_pair(5))
                flag = world.pops[selected_pos].claim(cursor_x, cursor_y, world)
                world.factions[p["name"]].cells.sort()
                if flag == 1:
                    p["c"] = (selected_pos, cursor_x, cursor_y)
                    timer = 5
                    flag = 0
        
            # Expand a settlement (s, b)
            if k == 98 and selected == 1:
                selected = 0
                world.pad.addstr(selected_pos[1],selected_pos[0],str(world.map[selected_pos]), curses.color_pair(5))
                popowner =  world.pops[selected_pos].owner
                # Build town
                if world.mat[selected_pos[1]][selected_pos[0]] == 7:
                    flag = world.pops[selected_pos].build_town(world)
                    local_refresh_pad(selected_pos[0],selected_pos[1],char_dict, col_dict, world)
                    world.factions[mainfac].settlements.sort()
                    if flag == 1:
                         p["bt"] = selected_pos
                         timer = 5
                         flag = 0
                # Build city
                elif world.mat[selected_pos[1]][selected_pos[0]] == 8:
                    flag = world.pops[selected_pos].build_city(world)
                    local_refresh_pad(selected_pos[0],selected_pos[1],char_dict, col_dict, world)
                    world.factions[mainfac].settlements.sort()
                    if flag == 1:
                        p["bc"] = selected_pos
                        timer = 5
                        flag = 0

            # Establish a colony (s, e)
            if k == 101:
                selected = 0
                world.pad.addstr(selected_pos[1],selected_pos[0],str(world.map[selected_pos]), curses.color_pair(5))
                nwpopname = names.pop()
                flag = world.pops[selected_pos].colonize(cursor_x, cursor_y, world, nwpopname)
                local_refresh_pad(cursor_x, cursor_y, char_dict, col_dict, world)
                world.factions[mainfac].settlements.sort()
                if flag == 1:
                    p["e"] = (selected_pos,cursor_x,cursor_y,nwpopname)
                    timer = 5
                    flag = 0
     
            # Build a fort (s, o)
            if k == 111:
                selected = 0
                flag = world.pops[selected_pos].build_fort(cursor_x, cursor_y, world)
                local_refresh_pad(cursor_x, cursor_y, char_dict, col_dict, world)
                world.pad.addstr(selected_pos[1],selected_pos[0],str(world.map[selected_pos]), curses.color_pair(5))
                world.factions[mainfac].settlements.sort()
                if flag == 1:
                    p["o"] = (selected_pos,cursor_x,cursor_y)
                    timer = 5
                    flag = 0

            # Upgrade a fort (s, o)
            if k == 111:
                selected = 0
                world.pad.addstr(selected_pos[1],selected_pos[0],str(world.map[selected_pos]), curses.color_pair(5))
                if world.mat[cursor_y][cursor_x] == 10:
                    flag = world.pops[selected_pos].upgrade_fort(cursor_x, cursor_y, world)
                    local_refresh_pad(cursor_x, cursor_y, char_dict, col_dict, world)
                    world.factions[mainfac].settlements.sort()
                    if flag == 1:
                        p["uo"] = (selected_pos,cursor_x,cursor_y)
                        timer = 5
                        flag = 0

             # Build a farm (s, f)
            if k == 102 and selected == 1:
                selected = 0
                world.pad.addstr(selected_pos[1],selected_pos[0],str(world.map[selected_pos]), curses.color_pair(5))
                flag = world.pops[selected_pos].build_farm(cursor_x, cursor_y, world)
                local_refresh_pad(cursor_x, cursor_y, char_dict, col_dict, world)
                if flag == 1:
                    p["f"] = (selected_pos, cursor_x, cursor_y)
                    timer = 5
                    flag = 0

         # Open menu (m)
        if k == 109:
            menu_pad = curses.newpad(10, 60)
            menu_pad.refresh( 0,0, 5,5, height-5,width-20)

        # Quit to menu (q)
        if k == 113:
            #main_menu(stdscr)
            sys.exit()

################################################################################
# Automatic operations

        # Make the pops and riches grow
        if calendar.month != grow_month:
            grow_month = calendar.month
            for pop in world.poplist:
                world.pops[pop].grow()
            for faction in world.factions.keys():
                world.factions[faction].get_wealth()

        # Produce food
        if calendar.year != grow_year:
            grow_year = calendar.year
            for pop in world.poplist:
                world.pops[pop].get_food(world)

        # Estimate faction sizes
        for faction in world.factions.keys():
            size = 0
            for pop in world.factions[faction].pops:
                size += int(world.pops[pop].size)
            world.factions[faction].size = size

################################################################################
# Screen operations

        # Initialization
        curses.curs_set(True)
        curses.napms(41) #41
        stdscr.erase()
        height, width = stdscr.getmaxyx()

        # The cursor will be moving in the pad
        cursor_y, cursor_x = trace_cursor(k, cursor_y, cursor_x)
        cursor_x = max(0, cursor_x)
        cursor_x = min(pwidth-2, cursor_x)
        cursor_y = max(0, cursor_y)
        cursor_y = min(pheight-2, cursor_y)

        # Scroll the world pad
        if cursor_y <= wpshow[0]-1:
            wpshow[0] = cursor_y
        elif cursor_y >= wpshow[0]+11:
            wpshow[0] = cursor_y-10
        if cursor_x <= wpshow[1]-1:
            wpshow[1] = cursor_x
        elif cursor_x >= wpshow[1]+11:
            wpshow[1] = cursor_x-10

        # Update and print date
        calendar.update()
        calstr = str(calendar)
        datstr = "╣ "+ p["name"] +", "+ calstr +" ╠"
        centpos = int((width // 2) - (len(datstr) // 2) - len(datstr) % 2)
        stdscr.addstr(0, centpos, datstr, curses.color_pair(5))

        # View faction data
        mainfac = list(world.factions.keys())[0]
        factstr = " ║ Size: "
        factstr += str(int(world.factions[mainfac].size))
        factstr += " ║ Wealth: "
        factstr += str(int(world.factions[mainfac].wealth))
        factstr += " ║"
        stdscr.addstr(1, 0, factstr)
        settlementstr = " ║ Settlements: "
        settlementstr += " ".join(world.factions[mainfac].settlements)
        settlementstr += " ║"
        stdscr.addstr(2, 0, settlementstr)
        claimedstr0 = " ║ Domains: "
        for cell in world.factions[mainfac].cells:
            claimedstr0 += char_dict[cell] +" "
        claimedstr0 += "║"
        stdscr.addstr(3, 0, claimedstr0)

        # View information on the map
        if (cursor_x,cursor_y) in world.factions[p["name"]].explored:
            view = " "+ type_dict[world.mat[cursor_y,cursor_x]]
            if (cursor_x,cursor_y) in world.pops.keys():
                view += ", "+ world.pops[(cursor_x,cursor_y)].name 
                view += " (" + world.pops[(cursor_x,cursor_y)].owner +")"
                view += ": "+ str(int(world.pops[(cursor_x,cursor_y)].size)) +" inhabitants."
                stdscr.addstr(height-8, 0, view)
                view = " Food: "+ str(int(world.pops[(cursor_x,cursor_y)].food))
                stdscr.addstr(height-7, 0, view)
                claimedstr = " Claimed territories: "
                for cell in world.pops[(cursor_x,cursor_y)].claimed:
                    claimedstr += char_dict[cell] +" "
                stdscr.addstr(height-6, 0, claimedstr)

            elif (cursor_x,cursor_y) in world.forts.keys(): 
                view += " (" + world.forts[(cursor_x,cursor_y)].owner +")"
                view += ": "+ str(int(world.forts[(cursor_x,cursor_y)].size)) +" strong."
                stdscr.addstr(height-8, 0, view)

            else:
                view += ", unpopulated."
                stdscr.addstr(height-8, 0, view)

        else:
            view = " Uncharted."
            stdscr.addstr(height-8, 0, view)


        # Render status bar
        playernames = []
        for player in players:
            playernames.append(player['name']) 
        #statusbarstr = " ║ Quit 'q' ║ "+ ' ╦ '.join(playernames) +" ║ Last: {} Pos: {}, {} ║"
        #statusbarstr = statusbarstr.format(k , cursor_y, cursor_x)
        statusbarstr = " Quit 'q' ║ "+ ' ╦ '.join(playernames) +" ║ Pos: {}, {}"
        statusbarstr = statusbarstr.format(cursor_y, cursor_x)
        stdscr.attron(curses.color_pair(4))
        stdscr.addstr(height-1, 0, statusbarstr)
        stdscr.addstr(height-1, len(statusbarstr), " " * (width - len(statusbarstr) - 1))
        stdscr.attroff(curses.color_pair(4))

        # Move the cursor
        world.pad.move(cursor_y, cursor_x)

        # Refresh the screen
        stdscr.refresh()

        # Refresh the world
        #world_pad.refresh( 0,0, 6,5, height-14,width-5)
        world.pad.refresh(wpshow[0],wpshow[1],6,5,16,15)

        # Get next input
        k = stdscr.getch()

################################################################################
# Main menu

def main_menu(stdscr):

    k = 0
    cursor_x = 0
    cursor_y = 0

    # Start colors in curses
    curses.start_color()
    curses.init_pair(1, curses.COLOR_CYAN, curses.COLOR_BLACK)
    curses.init_pair(2, curses.COLOR_RED, curses.COLOR_BLACK)
    curses.init_pair(3, curses.COLOR_BLACK, curses.COLOR_WHITE)

    # Loop where k is the last character pressed
    while True:

        if k == 10 and cursor_y == (height // 2) + 2:
            sys.exit()

        if k == 10 and cursor_y == (height // 2) + 1:
            cosmogon(stdscr)

        # Initialization
        curses.curs_set(False)
        stdscr.nodelay(False)
        stdscr.clear()
        height, width = stdscr.getmaxyx()

        if k == curses.KEY_DOWN:
            cursor_y = cursor_y + 1
        elif k == curses.KEY_UP:
            cursor_y = cursor_y - 1

        cursor_x = (width // 2)

        cursor_y = max(int((height // 2) + 1), cursor_y)
        cursor_y = min(int((height // 2) + 2), cursor_y)

        # Strings
        statusbarstr = " Miguel Romero 2020 | github.com/miferg "
        title = "COSMOGON"
        subtitle = "We are the chosen ones"

        # Centering calculations
        start_x_title = int((width // 2) - (len(title) // 2) - len(title) % 2)
        start_x_subtitle = int((width // 2) - (len(subtitle) // 2) - len(subtitle) % 2)
        start_y = int((height // 2) - 2)

        # Render status bar
        stdscr.attron(curses.color_pair(3))
        stdscr.addstr(height-1, 0, statusbarstr)
        stdscr.addstr(height-1, len(statusbarstr), " " * (width - len(statusbarstr) - 1))
        stdscr.attroff(curses.color_pair(3))

        # Turning on attributes for title
        stdscr.attron(curses.color_pair(2))
        stdscr.attron(curses.A_BOLD)

        # Rendering title
        stdscr.addstr(start_y-2, start_x_title, title)

        # Turning off attributes for title
        stdscr.attroff(curses.color_pair(2))
        stdscr.attroff(curses.A_BOLD)

        # Print rest of text
        stdscr.addstr(start_y, start_x_subtitle, subtitle)
        if cursor_y == (height // 2) + 1:
            stdscr.addstr(start_y + 3, (width // 2) - 2, 'Begin', curses.A_STANDOUT)
        else:
            stdscr.addstr(start_y + 3, (width // 2) - 2, 'Begin')
        if cursor_y == (height // 2) + 2:
            stdscr.addstr(start_y + 4, (width // 2) - 2, 'Exit', curses.A_STANDOUT)
        else:
            stdscr.addstr(start_y + 4, (width // 2) - 2, 'Exit')

        # Move the cursor
        stdscr.move(cursor_y, cursor_x)

        # Refresh the screen
        stdscr.refresh()

        # Wait for next input
        k = stdscr.getch()

################################################################################
# Begin

def main():
    #curses.wrapper(main_menu)
    curses.wrapper(cosmogon)

if __name__ == "__main__":
    main()
