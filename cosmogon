#! /usr/bin/python3
"""
Command line simulation application.

github.com/miferg
"""

import curses
import sys
import time
import random
import data.data as data
from data.classes import *

def trace_cursor(k, cursor_y, cursor_x):
    if k == 258:
        cursor_y = cursor_y + 1
    elif k == 336:
        cursor_y = cursor_y + 5
    elif k == 259:
        cursor_y = cursor_y - 1
    elif k == 337:
        cursor_y = cursor_y - 5
    elif k == 261:
        cursor_x = cursor_x + 1
    elif k == 402:
        cursor_x = cursor_x + 5
    elif k == 260:
        cursor_x = cursor_x - 1
    elif k == 393:
        cursor_x = cursor_x - 5
    return(cursor_y, cursor_x)

def unpause(paused, calendar, stdscr):
    # if paused, unpause
    calendar.unpause()
    stdscr.nodelay(True)
    return 0

def pause(paused, calendar, stdscr):
    # if unpaused, pause
    calendar.pause()
    stdscr.nodelay(False)
    return 1

def gen_world_pad(source):  # used when the matrix changed
    worldpad = curses.newpad(source.h+1, source.w+1)
    for i in range(0, source.h):
        for j in range(0, source.w):
            worldpad.addstr(i, j, str(source.map[(j,i)]), source.col[(j,i)])
    return(worldpad)

def refresh_pad(char_dict, col_dict, world):
     world.gen_map(char_dict)
     world.gen_col(col_dict)
     return gen_world_pad(world)

def cosmogon(stdscr):

    k = 0
    cursor_x = 0
    cursor_y = 0

    # Clear and refresh the screen for a blank canvas
    stdscr.clear()
    stdscr.refresh()

    # Start colors in curses
    curses.start_color()
    curses.init_pair(1, curses.COLOR_BLUE, curses.COLOR_BLACK)
    curses.init_pair(2, curses.COLOR_YELLOW, curses.COLOR_BLACK)
    curses.init_pair(3, curses.COLOR_GREEN, curses.COLOR_BLACK)
    curses.init_pair(4, curses.COLOR_BLACK, curses.COLOR_WHITE)
    curses.init_pair(5, curses.COLOR_RED, curses.COLOR_BLACK)
    curses.init_pair(6, curses.COLOR_BLACK, curses.COLOR_RED)

    col_dict = {
        1: curses.color_pair(1), # water ~
        2: curses.color_pair(1), # river ╬
        3: curses.color_pair(2), # plains ░
        4: curses.color_pair(3), # forest ¶
        5: curses.color_pair(4), # mountain ^
        6: curses.color_pair(2), # farms #
        7: curses.color_pair(5), # village ᵃ
        8: curses.color_pair(5), # town a
        9: curses.color_pair(5), # city A
        }

    # Load objects
    names = data.names
    random.shuffle(names)
    char_dict = data.char_dict
    type_dict = data.type_dict

    # Create a new world
    world = World(names.pop(), 30, 50)
    world.mat = data.testmat.copy()  # Use the provisional matrix 
    world.gen_map(char_dict)
    world.gen_col(col_dict)
    world_pad = gen_world_pad(world)

    # World is paused
    calendar = Calendar()
    paused = 1
    calendar.pause()

    # Initialize factions
    mainame = names.pop()
    world.factions[mainame] = Faction(mainame)

    # Start timer for growth and production
    grow_month = 1
    grow_year = 0

    # No settlements are currently selected
    selected = 0

    # Loop where k is the last character pressed
    while True:

        stdscr.clear()
        height, width = stdscr.getmaxyx()

#############################################################
# Input operations

        # Pause and unpause (p)
        if k == 112:
            if paused == 1: 
                paused = unpause(paused, calendar, stdscr) 
            else:
                paused = pause(paused, calendar, stdscr)

        # Create the first settlement (b)
        if k == 98 and paused ==1:
            if (cursor_x,cursor_y) not in world.pops.keys():
                world.create_pop(world, cursor_x,cursor_y, names.pop(), world.factions[mainame].name)
                paused = unpause(paused, calendar, stdscr)
                world_pad = refresh_pad(char_dict, col_dict, world)

        # Select and deselect a settlement (s)
        if k == 115:
            if selected == 0 and  world.mat[cursor_y][cursor_x] in (7,8,9):
                selected_pos = (cursor_x, cursor_y)
                paused = pause(paused, calendar, stdscr)
                world.col[(cursor_x, cursor_y)] = curses.color_pair(6)
                world_pad = gen_world_pad(world)
                selected = 1
            elif selected == 1:
                paused = unpause(paused, calendar, stdscr)
                world.col[selected_pos] = curses.color_pair(5)
                world_pad = gen_world_pad(world)
                selected = 0

        # Claim wilderness (s, c)
        if k == 99 and selected == 1:
            world.col[selected_pos] = curses.color_pair(5)
            selected = 0
            world.pops[selected_pos].claim(cursor_x, cursor_y, world)
            paused = unpause(paused, calendar, stdscr)
            world_pad = gen_world_pad(world)
        
        # Expand a settlement (s, b)
        if k == 98 and selected == 1:
            world.col[selected_pos] = curses.color_pair(5)
            selected = 0
            popowner =  world.pops[selected_pos].owner
            # Build town
            if world.mat[selected_pos[1]][selected_pos[0]] == 7:
                world.pops[selected_pos].build_town(world)
                world_pad = refresh_pad(char_dict, col_dict, world)
            # Build city
            elif world.mat[selected_pos[1]][selected_pos[0]] == 8:
                world.pops[selected_pos].build_city(world)
                world_pad = refresh_pad(char_dict, col_dict, world)
            paused = unpause(paused, calendar, stdscr)
            world_pad = gen_world_pad(world)

        # Establish a colony (s, e)
        if k == 101:
            world.col[selected_pos] = curses.color_pair(5)
            selected = 0
            world.pops[selected_pos].colonize(cursor_x, cursor_y, world, names.pop())
            world_pad = refresh_pad(char_dict, col_dict, world)
            paused = unpause(paused, calendar, stdscr)
            world_pad = gen_world_pad(world)

        # Build a farm (s, f)
        if k == 102 and selected == 1:
            world.col[selected_pos] = curses.color_pair(5)
            selected = 0
            world.col[selected_pos] = curses.color_pair(5)
            world.pops[selected_pos].build_farm(cursor_x, cursor_y, world)
            world_pad = refresh_pad(char_dict, col_dict, world)
            paused = unpause(paused, calendar, stdscr)
            world_pad = gen_world_pad(world)

        # Open menu (m)
        if k == 109:
            menu_pad = curses.newpad(10, 60)
            menu_pad.refresh( 0,0, 5,5, height-5,width-20)
            paused = pause(paused, calendar, stdscr)

        # Quit to menu (q)
        if k == 113:
            #main_menu(stdscr)
            sys.exit()

#############################################################
# Automatic operations

        # Make the pops and riches grow
        if calendar.month != grow_month:
            grow_month = calendar.month
            for pop in world.poplist:
                world.pops[pop].grow()
            for faction in world.factions.keys():
                world.factions[faction].get_wealth()

        # Produce food
        if calendar.year != grow_year:
            grow_year = calendar.year
            for pop in world.poplist:
                world.pops[pop].get_food(world)

        # Estimate faction sizes
        for faction in world.factions.keys():
            size = 0
            for pop in world.factions[faction].pops:
                size += int(world.pops[pop].size)
            world.factions[faction].size = size

        # sort each faction's claimed cells
        for faction in world.factions.keys():
            world.factions[faction].cells.sort()

#############################################################
# Screen operations

        # Initialization
        curses.curs_set(True)
        curses.napms(41)
        stdscr.clear()
        height, width = stdscr.getmaxyx()

        # The cursor will be moving in the pad
        pheight, pwidth = world_pad.getmaxyx()
        cursor_y, cursor_x = trace_cursor(k, cursor_y, cursor_x)
        cursor_x = max(0, cursor_x)
        cursor_x = min(pwidth-2, cursor_x)
        cursor_y = max(0, cursor_y)
        cursor_y = min(pheight-2, cursor_y)

        # Update and print date
        calstr = str(calendar)
        if paused == 0:
            calendar.update()
        datstr = " "+ world.name +", "+ calstr
        centpos = int((width // 2) - (len(datstr) // 2) - len(datstr) % 2)
        stdscr.addstr(0, centpos, datstr, curses.color_pair(5))

        # View faction data
        mainfac = list(world.factions.keys())[0]
        factstr = " "+ mainfac +", size: "
        factstr += str(int(world.factions[mainfac].size))
        factstr += ", wealth: "
        factstr += str(int(world.factions[mainfac].wealth))
        stdscr.addstr(1, 0, factstr)
        claimedstr0 = " Domains: "
        for cell in world.factions[mainfac].cells:
            claimedstr0 += char_dict[cell] +" "
        stdscr.addstr(2, 0, claimedstr0)

        # View information on the map
        view = " "+ type_dict[world.mat[cursor_y,cursor_x]] +", "
        if (cursor_x,cursor_y) in world.pops.keys():
            view += world.pops[(cursor_x,cursor_y)].name 
            view += " (" + world.pops[(cursor_x,cursor_y)].owner +")"
            view += ": "+ str(int(world.pops[(cursor_x,cursor_y)].size)) +" inhabitants."
            view += " Food: "+ str(int(world.pops[(cursor_x,cursor_y)].food))
            claimedstr = " Claimed territories: "
            for cell in world.pops[(cursor_x,cursor_y)].claimed:
                claimedstr += char_dict[cell] +" "
            stdscr.addstr(height-8, 0, claimedstr)

        else:
            view += 'unpopulated.'
        stdscr.addstr(height-9, 0, view)

        # Render status bar
        if paused == 0:
            statusbarstr = " Quit 'q' | Pause 'p' | Last: {} Pos: {}, {}"
        else:
            statusbarstr = " Quit 'q' | Unpause 'p' | Last: {} Pos: {}, {}"
        statusbarstr = statusbarstr.format(k , cursor_y, cursor_x)
        stdscr.attron(curses.color_pair(4))
        stdscr.addstr(height-1, 0, statusbarstr)
        stdscr.addstr(height-1, len(statusbarstr), " " * (width - len(statusbarstr) - 1))
        stdscr.attroff(curses.color_pair(4))

        # Move the cursor
        world_pad.move(cursor_y, cursor_x)

        # Refresh the screen
        stdscr.refresh()

        # Refresh the world
        world_pad.refresh( 0,0, 6,5, height-14,width-5)

        # Get next input
        k = stdscr.getch()

def main_menu(stdscr):

    k = 0
    cursor_x = 0
    cursor_y = 0

    # Start colors in curses
    curses.start_color()
    curses.init_pair(1, curses.COLOR_CYAN, curses.COLOR_BLACK)
    curses.init_pair(2, curses.COLOR_RED, curses.COLOR_BLACK)
    curses.init_pair(3, curses.COLOR_BLACK, curses.COLOR_WHITE)

    # Loop where k is the last character pressed
    while True:

        if k == 10 and cursor_y == (height // 2) + 2:
            sys.exit()

        if k == 10 and cursor_y == (height // 2) + 1:
            cosmogon(stdscr)

        # Initialization
        curses.curs_set(False)
        stdscr.nodelay(False)
        stdscr.clear()
        height, width = stdscr.getmaxyx()

        if k == curses.KEY_DOWN:
            cursor_y = cursor_y + 1
        elif k == curses.KEY_UP:
            cursor_y = cursor_y - 1

        cursor_x = (width // 2)

        cursor_y = max(int((height // 2) + 1), cursor_y)
        cursor_y = min(int((height // 2) + 2), cursor_y)

        # Strings
        statusbarstr = " Miguel Romero 2020 | github.com/miferg "
        title = "COSMOGON"
        subtitle = "We are the chosen ones"

        # Centering calculations
        start_x_title = int((width // 2) - (len(title) // 2) - len(title) % 2)
        start_x_subtitle = int((width // 2) - (len(subtitle) // 2) - len(subtitle) % 2)
        start_y = int((height // 2) - 2)

        # Render status bar
        stdscr.attron(curses.color_pair(3))
        stdscr.addstr(height-1, 0, statusbarstr)
        stdscr.addstr(height-1, len(statusbarstr), " " * (width - len(statusbarstr) - 1))
        stdscr.attroff(curses.color_pair(3))

        # Turning on attributes for title
        stdscr.attron(curses.color_pair(2))
        stdscr.attron(curses.A_BOLD)

        # Rendering title
        stdscr.addstr(start_y-2, start_x_title, title)

        # Turning off attributes for title
        stdscr.attroff(curses.color_pair(2))
        stdscr.attroff(curses.A_BOLD)

        # Print rest of text
        stdscr.addstr(start_y, start_x_subtitle, subtitle)
        if cursor_y == (height // 2) + 1:
            stdscr.addstr(start_y + 3, (width // 2) - 2, 'Begin', curses.A_STANDOUT)
        else:
            stdscr.addstr(start_y + 3, (width // 2) - 2, 'Begin')
        if cursor_y == (height // 2) + 2:
            stdscr.addstr(start_y + 4, (width // 2) - 2, 'Exit', curses.A_STANDOUT)
        else:
            stdscr.addstr(start_y + 4, (width // 2) - 2, 'Exit')

        # Move the cursor
        stdscr.move(cursor_y, cursor_x)

        # Refresh the screen
        stdscr.refresh()

        # Wait for next input
        k = stdscr.getch()


def main():
    #curses.wrapper(main_menu)
    curses.wrapper(cosmogon)

if __name__ == "__main__":
    main()
