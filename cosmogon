#! /usr/bin/python3
"""
Command line simulation application.

github.com/miferg
"""

import curses
import sys
import random
import data.data as data
from data.network import Network
from data.classes import *
from data.functions import *

################################################################################
# Main function

def cosmogon(stdscr):

    stdscr.nodelay(True)
    k = 0
    n = Network()

    # Clear and refresh the screen for a blank canvas
    stdscr.clear()
    stdscr.refresh()
    stdscr.idcok(False)
    stdscr.idlok(False)

    # Start colors in curses
    set_colors()

    col_dict = {
        1: curses.color_pair(1), # water ~
        2: curses.color_pair(1), # river ╬
        3: curses.color_pair(2), # plains ░
        4: curses.color_pair(3), # forest ¶
        5: curses.color_pair(4), # mountain ^
        6: curses.color_pair(2), # farms #
        7: curses.color_pair(5), # village ᵃ
        8: curses.color_pair(5), # town a
        9: curses.color_pair(5), # city A
        }

    # Load objects
    names = data.names
    random.shuffle(names)
    char_dict = data.char_dict
    type_dict = data.type_dict

    # Create a new world
    world = World(names.pop(), 30, 50)
    world.mat = data.testmat.copy()  # Use the provisional matrix 
    world.gen_map(char_dict)
    world.gen_col(col_dict)
    world_pad = gen_world_pad(world)
    pheight, pwidth = world_pad.getmaxyx()

    # Initialize factions
    # local faction
    p, calorigin = n.getP()
    world.factions[p["name"]] = Faction(p["name"])

    # remote factions
    players = n.send(p)
    for player in players:
        if player != p:
            world.factions[player["name"]] = Faction(player["name"])

    # Start the calendar
    calendar = Calendar()
    calendar.origin = float(calorigin)

    # Define the starting position
    if p == players[0]:
        wpshow = [0,0]
        cursor_x = 0
        cursor_y = 0
    else:
        wpshow = [pheight-12,pwidth-12]
        cursor_x = pwidth-2
        cursor_y = pheight-2

    # Start timer for growth and production
    grow_month = 1
    grow_year = 0

    # No settlements are currently selected
    selected = 0

################################################################################
# Main loop where k is the last character pressed
    while True:

        height, width = stdscr.getmaxyx()

################################################################################
# Network operations

        # Send current player and recieve all players
        players = n.send(p)

        for player in players:
            if player['name'] != p['name']:
                if "b" in list(player.keys()): # Build the first settlement
                    world.create_pop(world,player["b"][0],player["b"][1],player["b"][2],player["name"])
                    del player["b"]
                    world_pad = refresh_pad(char_dict, col_dict, world)
                elif "f" in list(player.keys()): # Build a farm
                    if world.factions[player['name']].wealth < world.pops[player["f"][0]].farmcost:
                        world.factions[player['name']].wealth += world.pops[player["f"][0]].farmcost
                    world.pops[player["f"][0]].build_farm(player["f"][1],player["f"][2],world)
                    del player["f"]
                    world_pad = refresh_pad(char_dict, col_dict, world)
                    world_pad = gen_world_pad(world)
                elif "c" in list(player.keys()): # Claim wilderness
                    if world.factions[player['name']].wealth < world.pops[player["c"][0]].claimcost:
                        world.factions[player['name']].wealth += world.pops[player["c"][0]].claimcost
                    world.pops[player["c"][0]].claim(player["c"][1],player["c"][2], world)
                    del player["c"]
            else:
                if "b" in list(player.keys()): # remove instruction Build the first settlement
                    del p["b"]
                elif "f" in list(player.keys()): # remove instruction Build a farm
                    del p["f"]
                elif "c" in list(player.keys()): # remove instruction Claim wilderness
                    del p["c"]

################################################################################
# Input operations

        # Build the first settlement (b)
        if k == 98:
            if (cursor_x,cursor_y) not in world.pops.keys():
                nwpopname = names.pop()
                world.create_pop(world, cursor_x,cursor_y, nwpopname, p["name"])
                p["b"] = (cursor_x, cursor_y, nwpopname)
                world_pad = refresh_pad(char_dict, col_dict, world)

        # Select and deselect a settlement (s)
        if k == 115:
            if selected == 0 and  world.mat[cursor_y][cursor_x] in (7,8,9):
                if world.pops[(cursor_x, cursor_y)].owner == p["name"]:
                    selected_pos = (cursor_x, cursor_y)
                    world.col[(cursor_x, cursor_y)] = curses.color_pair(6)
                    world_pad = gen_world_pad(world)
                    selected = 1
            elif selected == 1:
                world.col[selected_pos] = curses.color_pair(5)
                world_pad = gen_world_pad(world)
                selected = 0

        # Claim wilderness (s, c)
        if k == 99 and selected == 1:
            world.col[selected_pos] = curses.color_pair(5)
            selected = 0
            world.pops[selected_pos].claim(cursor_x, cursor_y, world)
            p["c"] = (selected_pos, cursor_x, cursor_y)
            world_pad = gen_world_pad(world)
        
        # Expand a settlement (s, b)
        if k == 98 and selected == 1:
            world.col[selected_pos] = curses.color_pair(5)
            selected = 0
            popowner =  world.pops[selected_pos].owner
            # Build town
            if world.mat[selected_pos[1]][selected_pos[0]] == 7:
                world.pops[selected_pos].build_town(world)
                world_pad = refresh_pad(char_dict, col_dict, world)
            # Build city
            elif world.mat[selected_pos[1]][selected_pos[0]] == 8:
                world.pops[selected_pos].build_city(world)
                world_pad = refresh_pad(char_dict, col_dict, world)
            world_pad = gen_world_pad(world)

        # Establish a colony (s, e)
        if k == 101:
            world.col[selected_pos] = curses.color_pair(5)
            selected = 0
            world.pops[selected_pos].colonize(cursor_x, cursor_y, world, names.pop())
            world_pad = refresh_pad(char_dict, col_dict, world)
            world_pad = gen_world_pad(world)

        # Build a farm (s, f)
        if k == 102 and selected == 1:
            world.col[selected_pos] = curses.color_pair(5)
            selected = 0
            world.pops[selected_pos].build_farm(cursor_x, cursor_y, world)
            p["f"] = (selected_pos, cursor_x, cursor_y)
            world_pad = refresh_pad(char_dict, col_dict, world)
            world_pad = gen_world_pad(world)

        # Open menu (m)
        if k == 109:
            menu_pad = curses.newpad(10, 60)
            menu_pad.refresh( 0,0, 5,5, height-5,width-20)

        # Quit to menu (q)
        if k == 113:
            #main_menu(stdscr)
            sys.exit()

################################################################################
# Automatic operations

        # Make the pops and riches grow
        if calendar.month != grow_month:
            grow_month = calendar.month
            for pop in world.poplist:
                world.pops[pop].grow()
            for faction in world.factions.keys():
                world.factions[faction].get_wealth()

        # Produce food
        if calendar.year != grow_year:
            grow_year = calendar.year
            for pop in world.poplist:
                world.pops[pop].get_food(world)

        # Estimate faction sizes
        for faction in world.factions.keys():
            size = 0
            for pop in world.factions[faction].pops:
                size += int(world.pops[pop].size)
            world.factions[faction].size = size

        # sort each faction's claimed cells
        for faction in world.factions.keys():
            world.factions[faction].cells.sort()

################################################################################
# Screen operations

        # Initialization
        curses.curs_set(True)
        curses.napms(41) #41
        stdscr.erase()
        height, width = stdscr.getmaxyx()

        # The cursor will be moving in the pad
        cursor_y, cursor_x = trace_cursor(k, cursor_y, cursor_x)
        cursor_x = max(0, cursor_x)
        cursor_x = min(pwidth-2, cursor_x)
        cursor_y = max(0, cursor_y)
        cursor_y = min(pheight-2, cursor_y)

        # Scroll the world pad
        if cursor_y <= wpshow[0]-1:
            wpshow[0] = cursor_y
        elif cursor_y >= wpshow[0]+11:
            wpshow[0] = cursor_y-10
        if cursor_x <= wpshow[1]-1:
            wpshow[1] = cursor_x
        elif cursor_x >= wpshow[1]+11:
            wpshow[1] = cursor_x-10

        # Update and print date
        calendar.update()
        calstr = str(calendar)
        datstr = "╣ "+ p["name"] +", "+ calstr +" ╠"
        centpos = int((width // 2) - (len(datstr) // 2) - len(datstr) % 2)
        stdscr.addstr(0, centpos, datstr, curses.color_pair(5))

        # View faction data
        mainfac = list(world.factions.keys())[0]
        factstr = " ║ Size: "
        factstr += str(int(world.factions[mainfac].size))
        factstr += " ║ Wealth: "
        factstr += str(int(world.factions[mainfac].wealth))
        factstr += " ║"
        stdscr.addstr(1, 0, factstr)
        claimedstr0 = " ║ Domains: "
        for cell in world.factions[mainfac].cells:
            claimedstr0 += char_dict[cell] +" "
        claimedstr0 += "║"
        stdscr.addstr(2, 0, claimedstr0)

        # View information on the map
        view = " "+ type_dict[world.mat[cursor_y,cursor_x]] +", "
        if (cursor_x,cursor_y) in world.pops.keys():
            view += world.pops[(cursor_x,cursor_y)].name 
            view += " (" + world.pops[(cursor_x,cursor_y)].owner +")"
            view += ": "+ str(int(world.pops[(cursor_x,cursor_y)].size)) +" inhabitants."
            stdscr.addstr(height-9, 0, view)
            view = " Food: "+ str(int(world.pops[(cursor_x,cursor_y)].food))
            stdscr.addstr(height-8, 0, view)
            claimedstr = " Claimed territories: "
            for cell in world.pops[(cursor_x,cursor_y)].claimed:
                claimedstr += char_dict[cell] +" "
            stdscr.addstr(height-7, 0, claimedstr)

        else:
            view += 'unpopulated.'
            stdscr.addstr(height-9, 0, view)

        # Render status bar
        playernames = []
        for player in players:
            playernames.append(player['name']) 
        #statusbarstr = " ║ Quit 'q' ║ "+ ' ╦ '.join(playernames) +" ║ Last: {} Pos: {}, {} ║"
        #statusbarstr = statusbarstr.format(k , cursor_y, cursor_x)
        statusbarstr = " ║ Quit 'q' ║ "+ ' ╦ '.join(playernames) +" ║ Pos: {}, {} ║"
        statusbarstr = statusbarstr.format(cursor_y, cursor_x)
        stdscr.attron(curses.color_pair(4))
        stdscr.addstr(height-1, 0, statusbarstr)
        stdscr.addstr(height-1, len(statusbarstr), " " * (width - len(statusbarstr) - 1))
        stdscr.attroff(curses.color_pair(4))

        # Move the cursor
        world_pad.move(cursor_y, cursor_x)

        # Refresh the screen
        stdscr.refresh()

        # Refresh the world
        #world_pad.refresh( 0,0, 6,5, height-14,width-5)
        world_pad.refresh(wpshow[0],wpshow[1],6,5,16,15)

        # Get next input
        k = stdscr.getch()

################################################################################
# Main menu

def main_menu(stdscr):

    k = 0
    cursor_x = 0
    cursor_y = 0

    # Start colors in curses
    curses.start_color()
    curses.init_pair(1, curses.COLOR_CYAN, curses.COLOR_BLACK)
    curses.init_pair(2, curses.COLOR_RED, curses.COLOR_BLACK)
    curses.init_pair(3, curses.COLOR_BLACK, curses.COLOR_WHITE)

    # Loop where k is the last character pressed
    while True:

        if k == 10 and cursor_y == (height // 2) + 2:
            sys.exit()

        if k == 10 and cursor_y == (height // 2) + 1:
            cosmogon(stdscr)

        # Initialization
        curses.curs_set(False)
        stdscr.nodelay(False)
        stdscr.clear()
        height, width = stdscr.getmaxyx()

        if k == curses.KEY_DOWN:
            cursor_y = cursor_y + 1
        elif k == curses.KEY_UP:
            cursor_y = cursor_y - 1

        cursor_x = (width // 2)

        cursor_y = max(int((height // 2) + 1), cursor_y)
        cursor_y = min(int((height // 2) + 2), cursor_y)

        # Strings
        statusbarstr = " Miguel Romero 2020 | github.com/miferg "
        title = "COSMOGON"
        subtitle = "We are the chosen ones"

        # Centering calculations
        start_x_title = int((width // 2) - (len(title) // 2) - len(title) % 2)
        start_x_subtitle = int((width // 2) - (len(subtitle) // 2) - len(subtitle) % 2)
        start_y = int((height // 2) - 2)

        # Render status bar
        stdscr.attron(curses.color_pair(3))
        stdscr.addstr(height-1, 0, statusbarstr)
        stdscr.addstr(height-1, len(statusbarstr), " " * (width - len(statusbarstr) - 1))
        stdscr.attroff(curses.color_pair(3))

        # Turning on attributes for title
        stdscr.attron(curses.color_pair(2))
        stdscr.attron(curses.A_BOLD)

        # Rendering title
        stdscr.addstr(start_y-2, start_x_title, title)

        # Turning off attributes for title
        stdscr.attroff(curses.color_pair(2))
        stdscr.attroff(curses.A_BOLD)

        # Print rest of text
        stdscr.addstr(start_y, start_x_subtitle, subtitle)
        if cursor_y == (height // 2) + 1:
            stdscr.addstr(start_y + 3, (width // 2) - 2, 'Begin', curses.A_STANDOUT)
        else:
            stdscr.addstr(start_y + 3, (width // 2) - 2, 'Begin')
        if cursor_y == (height // 2) + 2:
            stdscr.addstr(start_y + 4, (width // 2) - 2, 'Exit', curses.A_STANDOUT)
        else:
            stdscr.addstr(start_y + 4, (width // 2) - 2, 'Exit')

        # Move the cursor
        stdscr.move(cursor_y, cursor_x)

        # Refresh the screen
        stdscr.refresh()

        # Wait for next input
        k = stdscr.getch()

################################################################################
# Begin

def main():
    #curses.wrapper(main_menu)
    curses.wrapper(cosmogon)

if __name__ == "__main__":
    main()
