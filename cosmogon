#! /usr/bin/python3
"""
Command line simulation application.

github.com/miferg
"""

import curses
import sys
import time
import numpy
import random
import data.data as data

class Calendar(object):

    def __init__(self):
        self.month = 0
        self.year = 0
        self.origin = time.perf_counter()
        self.pausetime = 0
        self.pauseinit = 0

    def __str__(self):
        return "Year: {}, Month: {}".format(self.year, self.month + 1)

    def update(self):
        change = time.perf_counter() - self.origin - self.pausetime
        # month duration in seconds
        dur = 1
        self.year = int(change // (12 * dur))
        self.month = int((change % (12 * dur)) // dur)

    def pause(self):
        self.pauseinit = time.perf_counter()

    def unpause(self):
        self.pausetime += time.perf_counter() - self.pauseinit

class World(object):

    def __init__(self, name, h, w):
        self.name = name
        self.mat = numpy.random.randint(1,size=(h,w)) + 1
        self.h = h
        self.w = w
        self.pops = {}
        self.map = {}
        self.col = {}
        self.factions = {}
        self.poplist = []

    def __str__(self):
        return name

    def gen_terr(self): # generate terrain with probability functions, eventually...
        pass

    def gen_map(self, char_dict):
        for x in range(0,self.w):
            for y in range (0,self.h):
                self.map[(x,y)] = char_dict[self.mat[y,x]]

    def gen_col(self, col_dict):
        for x in range(0,self.w):
            for y in range (0,self.h):
                self.col[(x,y)] = col_dict[self.mat[y,x]]

    def create_pop(self,world,x,y,name,owner):
        if self.factions[owner].availpops >= 1:
            if world.mat[y][x] not in (1,2,7,8,9):
                self.pops[(x,y)] = Population(name, owner, x,y)
                self.mat[y][x] = 7
                self.poplist.append((x,y))
                self.factions[owner].pops.append((x,y))
                self.factions[owner].wealthrate += 1
                self.factions[owner].availpops += -1

class Population(object):

    def __init__(self, name, owner, x, y):
        self.name = name
        self.size = 100
        self.growth = 0.006
        self.owner = owner
        self.influence = {self.owner:100}
        self.cap = 10000
        self.farms = 2
        self.pos_x = x
        self.pos_y = y
        self.claimed = []
        self.ar = 1  # aggro range for farms and claims

    def grow(self, world):
        self.size = self.size + (self.size*self.growth*((self.cap-self.size)/self.cap))
        if self.size > self.cap:
            self.size = self.cap
        if self.size < 0:
            self.size = 0

    def build_farm(self, x, y, world):
        if self.farms > 0 and world.factions[self.owner].wealth >= 100:
            if self.pos_x + self.ar >= x >= self.pos_x - self.ar:
                if self.pos_y + self.ar >= y >= self.pos_y - self.ar:
                    if world.mat[y][x] in (3,4):
                        world.mat[y][x] = 6
                        self.growth += 0.004
                        self.farms += -1
                        world.factions[self.owner].wealthrate += 0.5
                        world.factions[self.owner].wealth += -100

    def claim(self, x, y, world):
        if world.mat[y][x] in (1,2,3,4,5):
            if world.mat[y][x] not in self.claimed:
                if self.pos_x + self.ar >= x >= self.pos_x - self.ar:
                    if self.pos_y + self.ar >= y >= self.pos_y - self.ar:
                        world.factions[self.owner].wealthrate += 0.5
                        self.claimed.append(world.mat[y][x])

    def turn(self):
        if len(list(self.influence.keys())) > 1:
            for other in list(self.influence.keys())[1:]:
                if self.influence[other] > self.influence[owner]:
                    self.owner = other

class Faction(object):

    def __init__(self, name):
        self.name = name
        self.size = 0
        self.knowfor = 0
        self.workfor = 0
        self.warfor = 0
        self.wealth = 0
        self.pops =[]
        self.wealthrate = 0
        self.availpops = 1

    def __srt__(self):
        return self.name +", "+ str(self.size) +" inhabitants."

    def get_wealth(self):
        self.wealth = self.wealth + self.wealthrate

def trace_cursor(k, cursor_y, cursor_x):
    if k == 258:
        cursor_y = cursor_y + 1
    elif k == 336:
        cursor_y = cursor_y + 5
    elif k == 259:
        cursor_y = cursor_y - 1
    elif k == 337:
        cursor_y = cursor_y - 5
    elif k == 261:
        cursor_x = cursor_x + 1
    elif k == 402:
        cursor_x = cursor_x + 5
    elif k == 260:
        cursor_x = cursor_x - 1
    elif k == 393:
        cursor_x = cursor_x - 5
    return(cursor_y, cursor_x)

def unpause(paused, calendar, stdscr):
    # if paused, unpause
    calendar.unpause()
    stdscr.nodelay(True)
    return 0

def pause(paused, calendar, stdscr):
    # if unpaused, pause
    calendar.pause()
    stdscr.nodelay(False)
    return 1

def gen_world_pad(source):
    worldpad = curses.newpad(source.h+1, source.w+1)
    for i in range(0, source.h):
        for j in range(0, source.w):
            worldpad.addstr(i, j, str(source.map[(j,i)]), source.col[(j,i)])
    return(worldpad)

def refresh_pad(char_dict, col_dict, world):
     world.gen_map(char_dict)
     world.gen_col(col_dict)
     return gen_world_pad(world)

def cosmogon(stdscr):

    k = 0
    cursor_x = 0
    cursor_y = 0

    # Clear and refresh the screen for a blank canvas
    stdscr.clear()
    stdscr.refresh()

    # Start colors in curses
    curses.start_color()
    curses.init_pair(1, curses.COLOR_BLUE, curses.COLOR_BLACK)
    curses.init_pair(2, curses.COLOR_YELLOW, curses.COLOR_BLACK)
    curses.init_pair(3, curses.COLOR_GREEN, curses.COLOR_BLACK)
    curses.init_pair(4, curses.COLOR_BLACK, curses.COLOR_WHITE)
    curses.init_pair(5, curses.COLOR_RED, curses.COLOR_BLACK)
    curses.init_pair(6, curses.COLOR_BLACK, curses.COLOR_RED)

    col_dict = {
        1: curses.color_pair(1), # water ~
        2: curses.color_pair(1), # river ╬
        3: curses.color_pair(2), # plains ░
        4: curses.color_pair(3), # forest ¶
        5: curses.color_pair(4), # mountain ^
        6: curses.color_pair(2), # farms #
        7: curses.color_pair(5), # village ᵃ
        8: curses.color_pair(5), # town a
        9: curses.color_pair(5), # city A
        }

    # Load objects
    popnames = data.popnames
    random.shuffle(popnames)
    char_dict = data.char_dict
    type_dict = data.type_dict

    # Create a new world
    world = World(popnames.pop(), 30, 50)
    world.mat = data.testmat.copy()  # Use the provisional matrix 
    world.gen_map(char_dict)
    world.gen_col(col_dict)
    world_pad = gen_world_pad(world)

    # World is paused
    calendar = Calendar()
    paused = 1
    calendar.pause()

    # Initialize factions
    mainame = popnames.pop()
    world.factions[mainame] = Faction(mainame)

    # Start timer for pops to grow
    grow_month = 1

    # No settlements are currently selected
    selected = 0

    # Loop where k is the last character pressed
    while True:

        stdscr.clear()
        height, width = stdscr.getmaxyx()

#############################################################
# Input operations

        # Pause and unpause (p)
        if k == 112:
            if paused == 1: 
                paused = unpause(paused, calendar, stdscr) 
            else:
                paused = pause(paused, calendar, stdscr)

        # Create a settlement (b)
        if k == 98 and paused ==1:
            if (cursor_x,cursor_y) not in world.pops.keys():
                world.create_pop(world, cursor_x,cursor_y, popnames.pop(), world.factions[mainame].name)
                world_pad = refresh_pad(char_dict, col_dict, world)
                paused = unpause(paused, calendar, stdscr)

        # Select and deselect a settlement (s)
        if k == 115:
            if selected == 0 and  world.mat[cursor_y][cursor_x] in (7,8,9):
                selected_pos = (cursor_x, cursor_y)
                paused = pause(paused, calendar, stdscr)
                world.col[(cursor_x, cursor_y)] = curses.color_pair(6)
                world_pad = gen_world_pad(world)
                selected = 1
            elif selected == 1:
                paused = unpause(paused, calendar, stdscr)
                world.col[selected_pos] = curses.color_pair(5)
                world_pad = gen_world_pad(world)
                selected = 0

        # Claim wilderness (s, c)
        if k == 99 and selected == 1:
            world.col[selected_pos] = curses.color_pair(5)
            selected = 0
            world.pops[selected_pos].claim(cursor_x, cursor_y, world)
            paused = unpause(paused, calendar, stdscr)
            world_pad = gen_world_pad(world)
        
        # Expand a settlement (s, b)
        if k == 98 and selected == 1:
            world.col[selected_pos] = curses.color_pair(5)
            selected = 0
            popowner =  world.pops[selected_pos].owner
            # Build town
            if world.mat[selected_pos[1]][selected_pos[0]] == 7:
                if world.factions[popowner].wealth >= 1000:
                    if world.pops[selected_pos].size >= 8000:
                        world.mat[selected_pos[1]][selected_pos[0]] = 8
                        world_pad = refresh_pad(char_dict, col_dict, world)
                        world.pops[selected_pos].cap = 100000
                        world.pops[selected_pos].farms += 1
                        world.pops[selected_pos].ar += 2
                        world.factions[popowner].wealth += -1000
                        world.factions[popowner].wealthrate += 2
            # Build city
            elif world.mat[selected_pos[1]][selected_pos[0]] == 8:
                if world.factions[popowner].wealth >= 10000:
                    if world.pops[selected_pos].size >= 80000:
                        world.mat[selected_pos[1]][selected_pos[0]] = 9
                        world_pad = refresh_pad(char_dict, col_dict, world)
                        world.pops[selected_pos].cap = 1000000
                        world.pops[selected_pos].farms += 2
                        world.pops[selected_pos].ar += 4
                        world.factions[popowner].wealth += -10000
                        world.factions[popowner].wealthrate += 4
            paused = unpause(paused, calendar, stdscr)
            world_pad = gen_world_pad(world)

        # Build a farm (s, f)
        if k == 102 and selected == 1:
            if world.mat[cursor_y][cursor_x] not in (8,9):
                world.col[selected_pos] = curses.color_pair(5)
                selected = 0
                world.col[selected_pos] = curses.color_pair(5)
                world.pops[selected_pos].build_farm(cursor_x, cursor_y, world)
                world_pad = refresh_pad(char_dict, col_dict, world)
                paused = unpause(paused, calendar, stdscr)
                world_pad = gen_world_pad(world)

        # Open menu (m)
        if k == 109:
            menu_pad = curses.newpad(10, 60)
            menu_pad.refresh( 0,0, 5,5, height-5,width-20)
            paused = pause(paused, calendar, stdscr)

        # Quit to menu (q)
        if k == 113:
            #main_menu(stdscr)
            sys.exit()

#############################################################
# Automatic operations

        # Make the pops and riches grow
        if calendar.month != grow_month:
            grow_month = calendar.month
            for pop in world.poplist:
                world.pops[pop].grow(world)
            for faction in world.factions.keys():
                world.factions[faction].get_wealth()

        # Estimate faction sizes
        for faction in world.factions.keys():
            size = 0
            for pop in world.factions[faction].pops:
                size += int(world.pops[pop].size)
            world.factions[faction].size = size

#############################################################
# Screen operations

        # Initialization
        curses.curs_set(True)
        curses.napms(41)
        stdscr.clear()
        height, width = stdscr.getmaxyx()

        # The cursor will be moving in the pad
        pheight, pwidth = world_pad.getmaxyx()
        cursor_y, cursor_x = trace_cursor(k, cursor_y, cursor_x)
        cursor_x = max(0, cursor_x)
        cursor_x = min(pwidth-2, cursor_x)
        cursor_y = max(0, cursor_y)
        cursor_y = min(pheight-2, cursor_y)

        # Update and print date
        calstr = str(calendar)
        if paused == 0:
            calendar.update()
        datstr = " "+ world.name +", "+ calstr
        centpos = int((width // 2) - (len(datstr) // 2) - len(datstr) % 2)
        stdscr.addstr(0, centpos, datstr, curses.color_pair(5))

        # View faction data
        mainfac = list(world.factions.keys())[0]
        factstr = " "+ mainfac +", size: "
        factstr += str(int(world.factions[mainfac].size))
        factstr += ", wealth: "
        factstr += str(int(world.factions[mainfac].wealth))
        stdscr.addstr(1, 0, factstr)

        # View information on the map
        view = " Viewing: {}, ".format(type_dict[world.mat[cursor_y,cursor_x]])
        if (cursor_x,cursor_y) in world.pops.keys():
            view += world.pops[(cursor_x,cursor_y)].name 
            view += " (" + world.pops[(cursor_x,cursor_y)].owner +")"
            view += ": "+ str(int(world.pops[(cursor_x,cursor_y)].size)) +" inhabitants."
            claimedstr = " Claimed: "
            for tile in world.pops[(cursor_x,cursor_y)].claimed:
                claimedstr += char_dict[tile] +" "
            stdscr.addstr(height-8, 0, claimedstr)

        else:
            view += 'unpopulated.'
        stdscr.addstr(height-9, 0, view)

        # Render status bar
        if paused == 0:
            statusbarstr = " Quit 'q' | Pause 'p' | Last: {} Pos: {}, {}"
        else:
            statusbarstr = " Quit 'q' | Unpause 'p' | Last: {} Pos: {}, {}"
        statusbarstr = statusbarstr.format(k , cursor_y, cursor_x)
        stdscr.attron(curses.color_pair(4))
        stdscr.addstr(height-1, 0, statusbarstr)
        stdscr.addstr(height-1, len(statusbarstr), " " * (width - len(statusbarstr) - 1))
        stdscr.attroff(curses.color_pair(4))

        # Move the cursor
        world_pad.move(cursor_y, cursor_x)

        # Refresh the screen
        stdscr.refresh()

        # Refresh the world
        world_pad.refresh( 0,0, 6,5, height-14,width-5)

        # Get next input
        k = stdscr.getch()

def main_menu(stdscr):

    k = 0
    cursor_x = 0
    cursor_y = 0

    # Start colors in curses
    curses.start_color()
    curses.init_pair(1, curses.COLOR_CYAN, curses.COLOR_BLACK)
    curses.init_pair(2, curses.COLOR_RED, curses.COLOR_BLACK)
    curses.init_pair(3, curses.COLOR_BLACK, curses.COLOR_WHITE)

    # Loop where k is the last character pressed
    while True:

        if k == 10 and cursor_y == (height // 2) + 2:
            sys.exit()

        if k == 10 and cursor_y == (height // 2) + 1:
            cosmogon(stdscr)

        # Initialization
        curses.curs_set(False)
        stdscr.nodelay(False)
        stdscr.clear()
        height, width = stdscr.getmaxyx()

        if k == curses.KEY_DOWN:
            cursor_y = cursor_y + 1
        elif k == curses.KEY_UP:
            cursor_y = cursor_y - 1

        cursor_x = (width // 2)

        cursor_y = max(int((height // 2) + 1), cursor_y)
        cursor_y = min(int((height // 2) + 2), cursor_y)

        # Strings
        statusbarstr = " Miguel Romero 2020 | github.com/miferg "
        title = "COSMOGON"
        subtitle = "We are the chosen ones"

        # Centering calculations
        start_x_title = int((width // 2) - (len(title) // 2) - len(title) % 2)
        start_x_subtitle = int((width // 2) - (len(subtitle) // 2) - len(subtitle) % 2)
        start_y = int((height // 2) - 2)

        # Render status bar
        stdscr.attron(curses.color_pair(3))
        stdscr.addstr(height-1, 0, statusbarstr)
        stdscr.addstr(height-1, len(statusbarstr), " " * (width - len(statusbarstr) - 1))
        stdscr.attroff(curses.color_pair(3))

        # Turning on attributes for title
        stdscr.attron(curses.color_pair(2))
        stdscr.attron(curses.A_BOLD)

        # Rendering title
        stdscr.addstr(start_y-2, start_x_title, title)

        # Turning off attributes for title
        stdscr.attroff(curses.color_pair(2))
        stdscr.attroff(curses.A_BOLD)

        # Print rest of text
        stdscr.addstr(start_y, start_x_subtitle, subtitle)
        if cursor_y == (height // 2) + 1:
            stdscr.addstr(start_y + 3, (width // 2) - 2, 'Begin', curses.A_STANDOUT)
        else:
            stdscr.addstr(start_y + 3, (width // 2) - 2, 'Begin')
        if cursor_y == (height // 2) + 2:
            stdscr.addstr(start_y + 4, (width // 2) - 2, 'Exit', curses.A_STANDOUT)
        else:
            stdscr.addstr(start_y + 4, (width // 2) - 2, 'Exit')

        # Move the cursor
        stdscr.move(cursor_y, cursor_x)

        # Refresh the screen
        stdscr.refresh()

        # Wait for next input
        k = stdscr.getch()


def main():
    #curses.wrapper(main_menu)
    curses.wrapper(cosmogon)

if __name__ == "__main__":
    main()
